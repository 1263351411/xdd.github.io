# 模块化

1. **模块的定义**：所有以.py结尾的Python源代码文件都是一个**模块**
    * 模块名也是个标识符。可以由字母、下划线和数字组成(注意：不能以数字开头，不能与关键字重名)
    * 模块就像工具包，要想使用这个工具包中的工具，就需要使用import导入这个模块
    * 在模块中定义的全局变量、函数都是模块能够提供给外界直接使用的工具  

* 一般来说，编程语言中，库、包、模块是同一种概念，是代码组织方式。
* Python中只有一种模块对象类型，但是为了模块化组织模块的便利，提供了"包"的概念。
* 模块module，指的是Python的源代码文件。  
* 包package，指的是模块组织在一起的和包名同名的目录及其相关文件。  

## 导入语句

|          语句           |   含义   |
| :---------------------- | :------- |
| import 模块1[,模块2...] | 完全导入 |
| import ... as ...       | 模块别名 |

* import 语句
    1. 找到指定的模块，加载和初始化它，生成模块对象。找不到，抛出异常
    2. 在import所在的作用域的局部命名空间中，增加名称和上一步创建的对象关联

* 简单示例

* import functools 表示将functools导入当前作用域中

````python
import functools #导入模块functools
print(dir()) #查看当前作用域的命名名空间
print(functools) #<module 'functools' from 'D:\\Application\\python\\ping\\lib\\functools.py'>
print(functools.wraps) #<function wraps at 0x000002969469EE18>
````

![modules_001](../../../img/python/modules_001.jpg)

* import os.path #导入os.path,在导入的同时，会将os和os.path加入当前命名空间

````python
import os.path #导入os.path,os加入当前名词空间
import sys
print(dir()) #[...,'os']
print(os)
print(os.path)
print(sys.modules.keys()) #查看系统已经加载的模块
````

![modules_002](../../../img/python/modules_002.jpg)

* import os.path as osp #导入os.path并赋给osp

````python
import os.path as osp # 导入os.path并赋给osp  
print(dir()) #[..., 'osp']  
print(osp) # <module 'ntpath' from 'path/to/path.py'>
````

* 导入的访问域控制

````python
def textimport():
    import os.path #局部，只能在局部访问
    print(dir())

textimport()
print(globals().keys())
#import os.stat #不可以，应为stat不是模块
````

![modules_003](../../../img/python/modules_003.jpg)

* 总结
    1. **导入顶级模块，其名称会加入到本地名词空间中，并绑定到其模块对象。**  
    2. **导入非顶级模块，只将其顶级模块名称加入到本地名词空间中。导入的模块必须使用完全限定名称来访问。**  
    3. **如果使用了as，as后的名称直接绑定到导入的模块对象，并将该名称加入到本地名词空间中。**  

## from语句

|         语句          |   含义   |
| :-------------------- | :------- |
| from...import...      | 部分导入 |
| from...import...as... | 别名     |

* **找到from子句中指定的模块，加载并初始化它(注意不是导入)**
* from子句导入的模块是否具有该名称的**属性**，有会优先导入该**属性**,如果没有会尝试导入该名称的**子模块**，如果依然没找到，则抛出ImportError异常。如果找到了会将这个名称保存到本地名称空间，如果有as子句，则使用as子句后的名称
* from后面只能是模块名称，或包名称
* from ... import后面可以跟随有效的名称。

* **使用import或者from...import导入的模块或函数，在内存中只存在一份，不会多次导入**  

````python
from os.path import exists #加载、初始化os、os.path模块，exists加入本地名词空间并绑定

print(exists)

import os.path

print(os.path.exists)
print(os.path.__dict__["exists"])
print(getattr(os.path,"exists"))
````

![modules_004](../../../img/python/modules_004.jpg)

* 别名

````python
from functools import wraps as wr,partial #别名wr
print(dir()) #[... 'wr',‘partial’]
````

* 当前名词空间中导入该模块指定的成员

````python
from pathlib import Path,PosixPath #在当前名词控件导入该模块指定的成员
print(dir()) #[...,"Path","PosixPath"]
````

* 在当前名词控件导入该模块所有公共成员(非下划线开头成员)或指定成员

````python
from pathlib import * #在当前名词控件导入该模块所有公共成员(非下划线开头成员)或指定成员
print(dir())  # [..., 'Path', 'PosixPath', 'PurePath', 'PurePosixPath', 'PureWindowsPath', 'WindowsPath']
````

## 自定义模块

自定义模块：**.py文件就是一个模块**

### 自定义模块命名规范

1. 模块名就是文件名
2. 模块名必须符合标识符的要求，是非数字开头的字母、数字和下划线的组合。
    * 例如：test-module.py这样的文件名不能作为模块名。也不要使用中文。
3. 不要使用系统模块名，避免冲突。除非你明确知道这个模块名的用途
4. 通常模块名为全小写，下划线来分割

## 模块的搜索顺序

使用sys.path查看搜索顺序

````python
import sys

# print(*sys.path,sep='\n')
for p in sys.path:
    print(p)
````

![modules_005](../../../img/python/modules_005.jpg)

* **sys.path是一个列表，记录了模块的默认搜索顺序，当加载一个模块的时候，需要从这些搜索路径从前到后依次查找，并不搜索这些目录的子目录。搜索到模块就加载，搜索不到就抛出异常。**
    1. 路径也可以为字典、zip文件、egg文件
        * .egg文件，由setuptools库创建的包，第三方库常用的格式。添加了元数据(版本号、依赖项等)信息的zip文件，实质上就是个zip文件
    2. 路径顺序为：
        * 程序主目录，程序运行的主程序脚本所在的目录
        * PYTHONPATH目录，环境变量PYTHONPATH设置的目录也是搜索模块的路径
        * 标准库目录，Python自带的库模块所在目录
* sys.path可以被修改，增加新的目录

## 模块的重复导入

* 模块不会产生重复导入的现象，所有加载的模块都会记录在**sys.modules**中，sys.modules是存储已经加载过的所有模块的字典。(注意：打印sys.modules可以看到os、os.path都已经加载了。)

````python
# test1.py文件如下
print("this is test1 module")

class A:
    def showmodule(self):
        print(1,self.__module__,self)
        print(2,self.__dict__)
        print(3,self.__class__.__dict__)
        print(4,self.__class__.__name__)

a = A()
a.showmodule()

# test2.py文件如下（运行test2.py）
import test1  #导入当前文件
print("local module")
import test1
import test1
````

![modules_0056(../../../img/python/modules_006.jpg)  

* 从执行结果来看，不会产生重复导入的现象。所有加载模块都会记录在**sys.modules**中。
* **sys.modules是存储已经加载过的所有模块的字典**。(打印sys.modules可以看到os,os.path都已经加载了)

## 模块的属性

|属性|含义|
|:---|:---|
`__file__`|字符串,源文件路径
`__cached__`|字符串，编译后的字节码文件路径
`__spec__`|显示模块的规范
`__name__`|模块名
`__package__`|当模块是包，同`__name__`;否则，可以设置为顶级模块的字符串

### 模块运行

1. `__name__`,没个模块都会定义一个`__name__`特殊变量来存储当前模块的名称，如果不指定，则默认为源代码文件名，如果是包则有限定名。

2. 解释器初始化的时候，会初始化sys.modules字典(保存已加载的模块),加载builtins(全局函数、常量)模块、`__main__`模块、sys模块，以及初始化模块搜索路径sys.path

3. Python是脚本语言，任何一个脚本都可以直接执行，也可以作为模块被导入。

4. 当从表中输入(命令行方式敲代码)、脚本($ python test.py)或交互式读取的时候，会将模块的`__name__`设置为`__main__`,模块的顶层代码就在`__main__`这个作用域中执行。
    * 顶层代码：模块中缩进最外层的代码。
5. 如果是import导入的，其`__name__`默认就是模块名

````python

````
