# 装饰器与functools模块

* 装饰器：本质就是一个函数，主要是为其他函数添加附加功能
    * 原则：不修改被修饰函数的源代码，不修改被修饰函数的调用方式。

## 简单示例

1. 加的原来一个加法器如下：

````python
def add(x,y):
    print("开始计算{}+{}".format(x,y))
    hh = x + y
    print("结果为：{}".format(hh))
    return hh
````

2. 现在需要在不改变原代码的情况下，不修改调用方式的情况下，对加法运算前后增加相应功能  
简单示实现如下：

````python
#原加法器
def add(x,y):
    print("开始计算{}+{}".format(x,y))
    hh = x + y
    print("结果为：{}".format(hh))
    return hh

def strengthen(fn):
    def _add(*args,**kwargs):
        print("加法前执行")
        fn(*args,**kwargs) #这里使用原理的加法器做运算
        print("加法后执行")
    return _add

add = strengthen(add)
add(5,4)
````  

![decorator003](https://raw.githubusercontent.com/1263351411/xdd.github.io/master/img/python/decorator003.jpg)  

* 上面代码中strengthen方法就对add加法器进行了装饰。
## 装饰器语法
* 在python中提供了一种语法糖，来方便使用者实现上述这种装饰功能。
简单代码如下：
````python
def strengthen(fn):
    def _add(*args,**kwargs):
        print("加法前执行")
        fn(*args,**kwargs) #这里使用原理的加法器做运算
        print("加法后执行")
    return _add 

#表示用strengthen装饰add方法
@strengthen    #注意@strengthen   等价于 add = strengthen(add) 
def add(x,y):
    print("开始计算{}+{}".format(x,y))
    hh = x + y
    print("结果为：{}".format(hh))
    return hh

add(5,4)
````  
![decorator004](https://raw.githubusercontent.com/1263351411/xdd.github.io/master/img/python/decorator004.jpg)  

## 装饰器语法糖，【@+表达式】  
@表达式  
函数  
等价于  函数名 = 表达式执行结果(函数名)  
* 注意：表达式的返回值一定要是一个函数。
* 注意：如果是多个装饰器装饰同一函数，装饰器执行顺序是**由近及远，由下及上**
    * 由近及远：里函数最近的装饰器先执行。
例如：
````python
import datetime,time

#定义修改注解函数，并将修改注解函数柯里化
def logg(fn):
    def copy_property(tofn):
        tofn.__name__ = fn.__name__
        tofn.__doc__ = fn.__doc__
        return tofn  #注意，这里需要将原函数返回。不然元函数值为none
    return copy_property

def strengthen(fn):
    """我是strengthen方法的注解"""
    @logg(fn) #等效于 wrapper = logg(fn)(wrapper)
    def wrapper(*args,**kwargs):
        """我是wraper方法的注解"""
        starttime = datetime.datetime.now()
        fn(*args,**kwargs) #这里使用原理的加法器做运算
        elapsedtime = datetime.datetime.now() - starttime
        print("耗时：{}".format(elapsedtime.total_seconds()))
    return wrapper 

@strengthen    #等效于add = strengthen(add)
def add(x,y):
    """我是add方法的注解"""
    print("开始计算{}+{}".format(x,y))
    time.sleep(1)
    hh = x + y
    print("结果为：{}".format(hh))
    return hh

add(5,4)
print(add.__name__)
# datetime.datetime.now()
````   
* 运行结果为：  
![decorator005](https://raw.githubusercontent.com/1263351411/xdd.github.io/master/img/python/decorator005.jpg) 
* 上面示例中，不仅对add函数做了装饰，而且还改变了装饰器的默认属性与add属性保持一致。

## functools模块

* functools.update_wrapper(wrapper,wrapped,assigned=WRAPPER_ASSIGNMENTS,updated=WRAPPER_UPDATES)
    * 功能类似上面代码中copy_property功能，帮助修改包装函数属性
    * wrapper 包装还是、被更新者（需要更新者）
    * wrapped 被包装函数、数据源
    * assigned=WRAPPER_ASSIGNMENTS 其中WRAPPER_ASSIGNMENTS是一个元组
        * WRAPPER_ASSIGNMENTS = ('\_\_module\_\_', '\_\_name\_\_', '\_\_qualname\_\_', '\_\_doc\_\_',
                       '\_\_annotations\_\_')
    * updated=WRAPPER_UPDATES 其中 WRAPPER_UPDATES是一个元组
        * WRAPPER_UPDATES = ('\_\_dict\_\_',)
    * 注意：在update_wrapper函数调用后，会新**增加一个__wrapped__属性，记录了被包装函数wrapped**
    * 原码如下：
    ![decorator006](https://raw.githubusercontent.com/1263351411/xdd.github.io/master/img/python/decorator006.jpg) 
* 使用update_wrapper函数修改属性值如下：
````python
import datetime,time,functools

#定义修改注解函数，并将修改注解函数柯里化
def logg(fn):
    def copy_property(tofn):
        tofn.__name__ = fn.__name__
        tofn.__doc__ = fn.__doc__
        return tofn  #注意，这里需要将原函数返回。不然元函数值为none
    return copy_property

def strengthen(fn):
    """我是strengthen方法的注解"""
#     @logg(fn) #等效于 wrapper = logg(fn)(wrapper)
    def wrapper(*args,**kwargs):
        """我是wraper方法的注解"""
        starttime = datetime.datetime.now()
        fn(*args,**kwargs) #这里使用原理的加法器做运算
        elapsedtime = datetime.datetime.now() - starttime
        print("耗时：{}".format(elapsedtime.total_seconds()))
    functools.update_wrapper(wrapper,fn)  #效果类似于logg(fn)(wrapper)
    return wrapper  

@strengthen    #等效于add = strengthen(add)
def add(x,y):
    """我是add方法的注解"""
    print("开始计算{}+{}".format(x,y))
    time.sleep(1)
    hh = x + y
    print("结果为：{}".format(hh))
    return hh

add(5,4)
print(add.__name__)
print()
add.__wrapped__(5,6)  #__wrapped属性值中保存了原来的被包装函数
# datetime.datetime.now()
````  
* 运行结果如下：  
![decorator007](https://raw.githubusercontent.com/1263351411/xdd.github.io/master/img/python/decorator007.jpg) 

* 其代码还可以修改为如下方式：
````python
import datetime,time,functools

#定义修改注解函数，并将修改注解函数柯里化
def logg(fn):
    def copy_property(tofn):
        tofn.__name__ = fn.__name__
        tofn.__doc__ = fn.__doc__
        return tofn  #注意，这里需要将原函数返回。不然元函数值为none
    return copy_property

def strengthen(fn):
    """我是strengthen方法的注解"""
#     @logg(fn) #等效于 wrapper = logg(fn)(wrapper)
    @functools.wraps(fn) #与logg(fn)类似
    def wrapper(*args,**kwargs):
        """我是wraper方法的注解"""
        starttime = datetime.datetime.now()
        fn(*args,**kwargs) #这里使用原理的加法器做运算
        elapsedtime = datetime.datetime.now() - starttime
        print("耗时：{}".format(elapsedtime.total_seconds()))
#     functools.update_wrapper(wrapper,fn)  #效果类似于logg(fn)(wrapper)
    return wrapper 

@strengthen    #等效于add = strengthen(add)
def add(x,y):
    """我是add方法的注解"""
    print("开始计算{}+{}".format(x,y))
    time.sleep(1)
    hh = x + y
    print("结果为：{}".format(hh))
    return hh

add(5,4)
print(add.__name__)
print()
add.__wrapped__(5,6)  #__wrapped属性值中保存了原来的被包装函数
# datetime.datetime.now()
````  
* 运行结果如下：  
![decorator008](https://raw.githubusercontent.com/1263351411/xdd.github.io/master/img/python/decorator008.jpg) 
* 上面改造中使用了@functools.wraps(fn)
* functools.wraps(wrapped,assigned = WRAPPER_ASSIGNMENTS,updated = WRAPPER_UPDATES)
    * 类似logg功能
    * wrapped被包装函数
    * assigned=WRAPPER_ASSIGNMENTS 其中WRAPPER_ASSIGNMENTS是一个元组
        * WRAPPER_ASSIGNMENTS = ('\_\_module\_\_', '\_\_name\_\_', '\_\_qualname\_\_', '\_\_doc\_\_',
                       '\_\_annotations\_\_')
    * updated=WRAPPER_UPDATES 其中 WRAPPER_UPDATES是一个元组
        * WRAPPER_UPDATES = ('\_\_dict\_\_',)
    * 注意：会新**增加一个__wrapped__属性，记录了被包装函数wrapped**
* wraps函数原码： 
![decorator009](https://raw.githubusercontent.com/1263351411/xdd.github.io/master/img/python/decorator009.jpg) 




