# 正则表达式
@[Toc]  
## 概述
1. 正则表达式，Regular Expression,缩写为regex、regexp、RE等
2. 正则表达式是文本处理极为重要的技术，用它可以对字符串按照某种规则进行检索、替换。   
参考[https://www.w3cschool.cn/regex_rmjc/](https://www.w3cschool.cn/regex_rmjc/)  
## 分类
1. BRE
    * 基本正则表达式，grep、sed、vi等软件支持。vim有扩展
2. ERE
    * 扩展正则表达式，egrep(grep-E)、sed -r等
3. PCRE
    * 几乎所有高级语言都是PCRE的方言或者变种。Python从1.6开始使用SRE正则表达式引擎，可以认为是PCRE的子集，对应模块re。
##基本语法
### 元字符metacharacter  
代码|说明|举例
|:--|:---|:---|
.|匹配除换行符外的任意一个字符|.
[abc]|字符集合，只能表示一个字符位置。匹配包含的任意一个字符|[abc]匹配plain中的'a'
[^abc]|字符集合，只能表示一个字符位置。能匹配除abc外的所有字符。|[^abc]可以匹配plain中的‘p’,'l','i'或者‘n’
[a-z]|字符返回，也是个集合，表示一个字符位置匹配所有包含的任意一个字符|常用[A-Z][0-9],或者[a-t]
[^a-z]|匹配除a到z外的所有字符|
\\b|单词的边界|\\bb在文本中吵到单词中b开头的b字符
\\B|不匹配单词的边界|t\\B包含t的单词但是不以t结尾的t字符，例如write。\Bb不以b开头的含有b的单词，例如able
\d|等价于[0-9]|
\D|等价于[^0-9]|
\s|匹配1位空白字符，包括换行符、制表符、空格\[\\f\\r\\n\\t\\v&nbsp;\]|
\S|匹配1位非空白字符\[^\\f\\r\\n\\t\\v&nbsp;\]|
\w|匹配[a-zA-Z0-9_],包括中文的字等。|
\W|匹配\w之外的字符  
### 字符转义
* 凡是在正则表达式中有特殊意义的符号。例如\.\^\*\\等符号，匹配时需要表示该符号可以使用转义符号转义。
* 转义符号右斜杠\\
* \r,\n转义后表示回车和换行
### 重复
|代码/语法|说明
|:--:|:--|
\*|重复零次或多次
+|至少重复一次或多次
?|只能重复零次或一次
{n}|重复n次
{n,}|最少重复n次或更多次
{n,m}|最少重复n次，最多重复m次
### 分支条件
|代码|说明|举例|
|:--|:--|:--|
x\|y|匹配x或者y|wood took foot food 使用w\|food或者(w\|f)ood

### 分组捕获
<table>
<tr>
    <th>名称</th>
    <th>代码</th>
    <th>说明</th>
    <th>举例</th>
</tr>
<tr>
    <td align="left"  colspan="4">捕获</td>
</tr>
<tr>
    <td align="left" >分组捕获</td>
    <td align="left" >(pattern)</td>
    <td align="left" >
        1.使用小括号指定一个子表达式，也叫分组<br/>
        2.捕获后会制动分配组号，<b>从1开始</b><br/>
        3.可以改变优先级
    </td>
    <td align="left" ></td>
</tr>
<tr>
    <td align="left" >重复利用分组</td>
    <td align="left" >\数字</td>
    <td align="left" >匹配对应的分组</td>
    <td align="left" >(very)&nbsp;\1匹配very&nbsp;very,但捕获的组group是very</td>
</tr>
<tr>
    <td align="left" >不需要分组</td>
    <td align="left" >(?:exp)</td>
    <td align="left" >如果仅仅为了改变优先级，就不需要捕获分组</td>
    <td align="left" ></td>
</tr>
<tr>
    <td align="left" >命名分组</td>
    <td align="left" >(?< name>exp)(?'name'exp)</td>
    <td align="left" >命名分组捕获，但是可以通过name访问分组<b>Python语法必须是(?P< name>exp)</b></td>
    <td align="left" ></td>
</tr>
<tr>
    <td align="left"  colspan="3">零宽断言</td>
    <td align="left" >wood took foot food</td>
</tr>
<tr>
    <td align="left" >零宽度正预测先行断言(也有人称为：前端锚定)</td>
    <td align="left" >(?=exp)</td>
    <td align="left" ><b>例如：【exp2(?=exp)】匹配exp2。断言自身(exp2)出现的位置的后面(即右边)能匹配表达式exp。</b><br/>也就是说"匹配字符"后面跟个先行断言。判断匹配的字符后面是否满足断言条件。</td>
    <td align="left" >【f(?=oo)】会匹配f。但匹配到的f后面在原字符中一定会有oo</td>
</tr>
<tr>
    <td align="left" >零宽度正回顾后发断言（也有人称为：后端锚定）</td>
    <td align="left" >(?<=exp)</td>
    <td align="left" ><b>例如：【(?<=exp)exp2】匹配exp2。断言自身(exp2)出现的位置的前面(即左边)能匹配表达式exp。</b><br/>也就是说"匹配字符"前面加个后发断言。判断匹配的字符前面是否满足断言条件。</td>
    <td align="left" >【(?<=f)ood】会分别匹配ood、ood但其在原文中对应位置前面一定有f存在。<br/>【(?<=t)ook】会匹配ook，但ook在原文中对应位置前面一定存在t</td>
</tr>
<tr>
    <td align="left"  colspan="4">负向零宽断言</td>
</tr>
<tr>
    <td align="left" >零宽度负预测先行断言</td>
    <td align="left" >(?!exp)</td>
    <td align="left" ><b>例如：【exp2(?!exp)】匹配exp2。断言次位置(exp2)后面不能匹配表达式exp。</b><br/>与零宽度正预测先行断言相反。</td>
    <td align="left" >【\d{3}(?!\d)】匹配3位数字，断言3位数字后面一定不能是数字<br/>【foo(?!d)】匹配foo。但foo在原文中的对应位置后面一定不会出现d</td>
</tr>
<tr>
    <td align="left" >零宽度负回顾后发断言</td>
    <td align="left" >(?< !exp>)</td>
    <td align="left" ><b>例如：【(?< !exp)exp2】匹配exp2。断言此位置(exp2)的前面不能匹配表达式exp。</b><br/>与零宽度正回顾后发断言相反</td>
    <td align="left" >【(?< !f)ood】匹配ood，但ood在原文对应位置的前面一定不是f。</td>
</tr>
<tr>
    <td align="left"  colspan="4">注释</td>
</tr>
<tr>
    <td align="left" >注释</td>
    <td align="left" >(?#comment)</td>
    <td align="left" >在正则表达式中插入注释(不推荐使用)</td>
    <td align="left" >【f(?=oo)(?#这个后断言不捕获)】</td>
</tr>
</table>   

* **注意**
1. **断言不占分组号。断言如同条件，只是要求匹配必须满足断言的条件。**
2. **使用正则表达式时，能用简单表达式，就不要复杂的表达式**
3. 注释也可以如下方式写
````re
(?<= # 断言要匹配的文本的前缀
<(\w+)> # 查找尖括号括起来的字母或数字(即HTML/XML标签)
) # 前缀结束
.* # 匹配任意文本
(?= # 断言要匹配的文本的后缀
<\/\1> # 查找尖括号括起来的内容：前面是一个"/"，后面是先前捕获的标签
) # 后缀结束
````
### 贪婪与非贪婪
1. 正则表达式默认是：**贪婪模式**，也就是说尽量多匹配更长的字符串。
2. **非贪婪**：在重复符号后面加上一个?问号，就是非贪婪。即：尽量的少匹配。  

|代码|说明|
|:--|:--|
*?|重复匹配任意次，但尽可能少重复
+?|重复匹配1次或更多次,但尽可能少重复
??|重复匹配0次或1次，但尽可能少重复
{n,m}?|重复n到m次，但尽量可能少重复
{n,}?|重复n次以上，但尽量可能少重复


### 引擎选项(处理选项)
|代码|名称|说明|Python|
|:--|:---|:------|:------|
ignoreCase|忽略大小写|匹配时不区分大小写|re.I<br/>re.IGNORECASE
Singleline|单行模式|单行模式。<br/>注意：单行模式中.可以匹配所有字符，包括\n|re.S<br/>re.DOTALL
Multiline|多行模式|多行模式。<br/>注意：更改^和$的含义，使他们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含义是：匹配\\n之前的位置以及字符串结束前的位置。)|re.M <br/> re.MULTILINE
IgnorePatternWhitespace|忽略空白|忽略表达式中的非转义空白，并启用由#标记的注释。<br>1.如果要使用空白字符用转义。<br>2.#可以用来做注释|re.X<br/>re.VERBOSE
ExplicitCapture|显示捕获|仅捕获已被显示命名的组|  

* 注意：
1. 多行模式和单行模式这两个选项之间没有任何关系，除了他们的名字比较相似，让人容易感到疑惑以外。不会不会互相干扰。
2. 单行模式，多行模式，默认模式中的区别
* 默认模式：
    【.】 匹配任意字符，但不包括换行符\\n
    【^】 匹配首部(字符串的开始位置)。即行首。不会受换行符\\n的影响而重新将\\n的后面认为是新的首部。（即待匹配的文本是一行）
    【&】 匹配尾部(字符串的结束位置)。即行尾。不会受换行符\\n的影响而重新将\\n的前面认为是新的尾部。(即待匹配的文本是一行)
* 单行模式：
    【.】**被重新定义** 可以匹配所有字符，包括换行符\\n，
    【^】表示整个字符串的开头，与默认模式相同
    【$】表示整个字符串的结尾。与默认模式相同
* 多行模式：
    【.】匹配任意字符，但不包括换行符\\n
    【^】**被重新定义** 可以匹配首部(字符串的开始位置)，和换行符\n后面一行的行首位置。
    【&】**被重新定义** 可以匹配尾部（字符串的结束位置），和换行符\n前面一行的行尾位置。  
### 总结
1. **单行模式**，只改变了字符【.】的意义。**多行模式**,只改变字符【^和$】的意义。互不干扰。
2. 正则表达式中每一种模式都是独立修改的，都不会互相干扰，模式只是表示一种状态。不同模式可以混合使用。
3. 正则表达式中只认换行符\\n，而windows中的换行符是\\r\\n,字符串中有\\r\\n这种\\r的隐藏字符注意匹配结果是否会多出\\r这个空白字符。

### 示例
* 匹配一个0-999之间的任意数字
>正则表达式为：````"([\d]{1,3})\s"````  
![re002](https://raw.githubusercontent.com/1263351411/xdd.github.io/master/img/python/re002.jpg)  
* 匹配邮箱地址
>正则表达式为： ````"[\w-.]*@[\w-.]*\.[a-zA-Z]*(?:\.[a-zA-Z]*)?"````  
![re003](https://raw.githubusercontent.com/1263351411/xdd.github.io/master/img/python/re003.jpg)   
* 匹配座机号和手机号   
> 正则表达式为：   
````"(?<=\D?[^1-9])(?:(?:\d{3}(?:(?:\d-)|(?:-\d))\d{7})|\d{11})(?=\D)"````  

> 匹配字符串为：
````
ab15936278529
025-83105736
0543-5467328
015893526408
121536252536
152425648
````  
> 运行结果：   
![re001](https://raw.githubusercontent.com/1263351411/xdd.github.io/master/img/python/re001.jpg)  
* 匹配强密码
    * 要求密码必须由10-15位指定字符组成：  
        2. 十进制数字  
        3. 大写字母  
        4. 小写字母  
        5. 下划线  
    * 要求四种类型的字符都要出现的合法的强密码  
1. 使用先行断言匹配   
> 正则表达式为：````"(^(?=.*[a-z])(?=.*[0-9])(?=.*[A-Z])(?=.*[_*@#$%]).{10,15}$)"````    
![re004](https://raw.githubusercontent.com/1263351411/xdd.github.io/master/img/python/re004.jpg) 
2. 使用后发断言匹配
> 正则表达式为： ````"(^.{10,15}$(?<=[a-z].*)(?<=[1-9].*))(?<=[A-Z].*)(?<=[_*()&^].*)"````    
![re005](https://raw.githubusercontent.com/1263351411/xdd.github.io/master/img/python/re005.jpg) 










