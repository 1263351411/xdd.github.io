# 关系模型和SQL

为了介绍关系模型，以MySQL数据为例。

* 安装MariaDB

````shell
#安装mariadb
> yum install mariadb-server
#启动服务
> systemctl start mariadb.service
#开机启动
> systemctl enble mariadb.service
# 为了安全设置Mysql服务
> mysql_secure_installation
# 数据库密码登录
> mysql -u root -p
# 显示所有数据库
mysql> show databases;
# 创建用户并授权
mysql> grant all on *.* to 'xdd'@'%' identified by 'xdd';
mysql> flush privileges;
# 导入测试脚本
> mysql -u root -p < test.sql
````

## SQL语句

* SQL是结构化查询语言Structured Query Language。1987年被ISO组织标准化。  
* 所有主流的关系型数据库都支持SQL，NoSQL也有很大一部分支持SQL。

* SQL语句分为：
    1. **DCL数据库控制语言**
        * 负责数据库权限访问控制，由GRANT和REVOKE两个指令组成
    2. **DDL数据定义语言**
        * 负责数据库定义，数据库对象定义，由CREATE,ALTER与DROP三种语句组成
    3. **DML数据库操作语言**
        * 负责对数据库对象的操作，CRUD增删改查
    4. **TCL事务控制语言**
        * 负责处理ACID事务，支持commit、rollback指令

* 语言规范
    1. SQL语句大小写不敏感
        * 一般建议，SQL的关键字、函数等大写
    2. SQL语句末尾应该使用分号结束
    3. 注释
        * 多行注释 `/*注释内容*/`
        * 单行注释 `-- 注释内容`
        * MySQL注释可以使用#
    4. 使用空格或缩进来提高可读性
    5. 命名规范
        * 必须以字母开头
        * 可以使用数字、#、$和_
        * 不可使用关键字

## DDL命令

## DCL数据库控制语言

GRANT授权，REVOKE撤销  

````slq
GRANT ALL ON employees.* TO 'xdd'@'%' IDENTIFIED by 'xdd';
REVOKE ALL ON *.* FROM xdd;
````

1. 常用特殊符号
    * `*`为通配符，代指任意库或者任意表。
    * `*.*`所有库的所有表。
    * `employess.*`表示employees库下所有的表
    * `%`为通配符，它是SQL语句的通配符，匹配任意长度字符串

## DDL数据库定义语言

1. 删除用户(慎用)

    ````sql
    DROP USER xdd;
    ````

2. 创建数据库
    * 库是数据的集合，所有数据按照数据模型组织在数据库中。

    ````sql
    CREATE DATABASE IF NOT EXISTS test CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
    CREATE DATABASE IF NOT test CHARACTER SET utf8;
    ````

    * CHARACTER SET指定数据库字符集。
        1. utf8mb4是utf8的扩展。支持4字节utf8mb4,需要MySQL5.5.3+。
    * COLLATE指定字符集的校对规则，用来做字符串的比较。
3. 删除数据库

    ````sql
    DROP DATABASE IF EXISTS gogs;
    ````

4. 创建表
    * 表分为行和列，MySQL是行存数据库。数据是一行行存的，列必须固定多少列。
        * 行Row,也称为记录Record，元组。
        * 列Column,也称为字段Field、属性。
    * 字段的取值范围叫做域Domain。例如gender字段的取值就是M或者F两个值。
    * 反引号标注的名称，会被认为是非关键字，使用反引号避免冲突。

    ````sql
    CREATE TABLE `xddtable` (
        `emp_no` int(11) NOT NULL,
        `birth_date` date NOT NULL,
        `first_name` varchar(14) NOT NULL,
        `last_name` varchar(16) NOT NULL,
        `gender` enum('M','F') NOT NULL,
        `hire_date` date NOT NULL,
        PRIMARY KEY (`emp_no`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    ````

5. DESC查看列信息
    * 语法`{DESCRIBE | DESC} tb|_name [col_name | wild]`

    ````sql
    DESC xddtable;
    DESC xddtable '%name'
    ````

* 练习 设计一张表，记录登录账户的注册信息，应该存储用户的姓名、登录名、密码

````sql
DROP DATABASE IF EXISTS test;
CREATE DATABASE IF NOT EXISTS test CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
use test;
CREATE TABLE `reg` (
    `id` int(11) NOT NULL,
    `loginname` varchar(50) NOT NULL,
    `name` varchar(64) DEFAULT NULL,
    `password` varchar(128) NOT NULL,
    PRIMARY KEY (`id`)
) Engine = InnoDB
````

### 数据类型

* MySQL中的数据类型

|类型|含义|
|:-----|:-------|
tinyint|**1字节**，带符号的范围是[-128,127]。无符号的范围是[0,255]。<br/>bool或boolean，就是tinyint，0表示假,非0表示真
smallint|**2字节**，带符号的分为是[-32768,32767]。无符号的范围是[0,65535]
int|**整形，4字节**，同Integer,带符号的范围是[-21474483648,2147483647]。无符号的范围是[0,4294967295]
bigint|**长整形，8字节**，同Integer,带符号的范围是[-9223372036854775808,9223372036854775807]。无符号的范围是[0,18446744073709551615]
float|**单精度浮点数**精确到大约7位小数位
double|**双精度浮点数**精度确到大约15位小数位
DATE|日期。支持的范围为'1000-01-01'到'9999-12-31'
DATETIME|支持的范围是'1000-01-01 00:00:00'到'9999-12-31 23:59:59'
TIMESTAMP|时间戳。范围是'1970-01-01 00:00:00'到2037年
char(M)|固定长度，右边填充空格以达到长度要求。M为长度，范围为[0-255]。<br/>M指代字符个数
varchar(M)|变长字符串。M表示最大列长度。M的范围是[0-65535]。但不能突破行最大字节数65535
text|大文本。最大长度为65535($2^{16}-1$)个字符
BLOB|大字节。最大长度为65535($2^{16}-1$)字节的BLOB列

* LENGTH()函数返回字节数。而char和varchar定义的M是字符数限制。
* char可以将字符串定义为固定长度，空间换时间，效率略高；varchar为变长，省了空间。

### 关系

* 在关系数据库中，关系就是二维表，由行和列组成。  
    1. 行Row,也称为记录Record,元组。
    2. 列Column,也称为字段Field、属性。
* 字段的取值范围叫做**域**Domain。例如gender字段的取值就是M或者F两个值。
* **维数**：关系的维数指关系中属性的个数
* **基数**：元组的个数

**注意**：在关系中，属性的顺序并不重要。理论上，元组顺序也不重要，但是由于元组顺序与存储相关，会影响查询效率。

### 候选键

* 关系中，能位移标识一条元组的属性或属性集合，称为候选键。

### PRIMARY KEY 主键

* 表中一列或多个列组成唯一的key,也就是通过这一个或者多个列能唯一的标识一条记录。即被选择的候选键。  
* 主键的列不能包含空值null。主键往往设置为整型、长整型，可以为自增AUTO_INCREMENT字段。
* 表中可以没有组件，但是，一般表设计中，往往都会有主键，以避免记录重复。

### Foreign KEY外键

* 严格来说，当一个关系中的某个属性或属性集合与另一个关系(也可以是自身)的候选键匹配时，就称作这个属性或属性结合是外键。

### 索引Index

* 可以看做是一本字典的目录，为了快速检索用的。空间换时间，显著提高查询效率。
* 可以对一列或者多列字段设定索引。
    1. **主键索引**：主键会自动建立主键索引，主键本身就是为了快速定位唯一记录的。
    2. **唯一索引**：表中的索引列组成的索引必须唯一，但可以为空，非空必须唯一。
    3. **普通索引**：没有唯一性的要求，就是建了一个字典的目录而已。
* 在MySQL中，InnoDB和MyLSAM的索引数据结构可以使用Hash或BTree，默认是BTree。
    1. Hash时间复杂度是O(1),但是只能进行精确度匹配，也就是Hash值的匹配，比如范围匹配就没办法了，hash值无序所以无法知道原有记录的顺序。Hash问题较多。
    2. BTree索引，以B+树为存储结构。虽然索引可以提高查询所读，但是却影响增删改的效率，因为需要索引更新或重构。频繁出现在where子句中的列可以考虑使用索引。要避免把性别这种字段设索引。

### 约束Constraint

* 为了保证数据的完整正确，数据模型还必须支持完整性约束。  
* "必须有值"约束：某些列的值必须有值，不许为空NULL。

### 域约束Domain Constraint

限定了表中字段的取值范围

### 实体完整性Entity Integrity

PRIMARY KEY约束定义了主键，就定义了**主键约束**。主键不重复且唯一，不能为空。

### 引用完整性Referential Integrity ***

* 外键定义中，可以不是引用另一张表的主键，但是，往往实际只会关注引用主键。
* 外键：在表B中的列，引用了表A中的主键，表B中的列就是外键。A表称为主表，B表称为从表

1. **插入规则**
    * 不需要指定。
    * 如果在表B插入一条记录，B的外键列插入了一个值，这个值必须是表A中存在的主键值。
2. **更新规则**
    * 定义外键约束时指定该规则。
3. **删除规则**
    * 定义外键约束时指定该规则。

* **外键约束的操作**
    1. 外键约束，是为了保证数据完整性、一致性，杜绝数冗余、数据错误。

|**设定值**|**说明**|
|:-------|:-------|
CASCADE|级联，从父表删除或更新会自动删除或更新子表中匹配的行
SET NULL|从父表删除或更新行，会设置字表中的外键为NULL，但必须保证字表列没有指定NOT NULL，也就是说子表的字段可以为NULL才行。
RESTRICT|如果从附表删除主键，如果子表引用了，则拒绝对父表的删除或更新操作
NO ACTION|标准SQL的关键字，在MySQL中与RESTRICT相同。拒绝对父表的删除或更新操作

### 实体-联系E-R

数据库建立，需要搜集用户需求，设计符合企业要求的数据模型。而构建这种模型需要方法，这种方法需要称为E-R实体-联系建模。也出现了一种建模语言--UML(Unified Modeling Language)统一建模语言。

* 实体Entity:现实世界中具有相同属性的一组对象，可以是物理存在的事物或抽象的事物。
* 联系Relationship:实体之间的关联集合。

* **实体间联系类型**  
假设有实体部门，实体员工  

|类型|描述|解决方案|
|:-----|:--------|:-------|
一对多联系1:n|一个员工属于一个部门，一个部门有多个员工|员工外键：部门主键
多对多联系m:n|一个员工属于多个部门，一个部门有多个员工|建立第三表
一对一联系1:1|假设有实体管理者，一个管理者管理一个部门，一个部门只有一个管理者|字段健在哪张表都行

* 一对一关系用的比较少，往往表示表A的一条记录唯一关联表B的一条记录，反之亦然。
* 它往往是为了将一张表多列分割并产生了多张表，合起来是完整的信息，或为了方便查询，或为了数据安全隔离一部分字段数据等等。

## 视图

* 视图，也称为虚表，看起来像表。它是由查询语句生成的。可以通过视图进行CRUD操作。  
* 视图的作用
    1. 简化操作，将复杂查询SQL语句定义为视图，可以简化查询。
    2. 数据安全，视图可以只显示真实表的部分列，或计算后的结果，从而隐藏真实表的数据

## 关系操作

* **关系**：在关系数据库中，关系就是二维表。关系操作就是表的操作。
* **选择(selection)**: 又称为限制，是从关系中选择出满足给定条件的元组。
* **投影(projection)**: 在关系上投影就是从选择出诺干属性列组成新的关系。
* **链接(join)**:将不同的两个关系链接成一个关系。

## DML--CRUD增删改查

1. **Insert语句 插入语句**
    * 语法：`INSERT INTO 表名[(插入的字段名，插入的字段名，...)] VALUES (对应的字典内容，对应的字段内容，...)`

    ````sql
    INSERT INTO table_name (col_name,...) VALUES (value1,...);
    -- 向表中插入一行数据，自增字段、缺省值字段、可为空字段可以不写

    INSERT INTO table_name SELECT ... ;
    -- 将select查询的结果插入到表中

    INSERT INTO table_name (col_name1,...) VALUES (value1,...) ON DUPLICATE KEY UPDATE col_name1=value1,...;
    -- 如果主键冲突、唯一键冲突就执行update后的设置。这条语句的意思，就是主键不在新增记录，主键在就更新部分字 段。

    INSERT IGNORE INTO table_name (col_name,...) VALUES (value1,...);
    -- 如果主键冲突、唯一键冲突就忽略错误，返回一个警告。
    ````

    ````sql
    INSERT INTO reg (loginname,`name`,`password`) VALUES ('tom','tom','tom');
    INSERT INTO reg (id,loginname,`name`,`password`) VALUES (5,'tom','tom','tom');
    INSERT INTO reg (id,loginname,`name`,`password`) VALUES (5,'tom','tom','tom') ON DUPLICATE KEY UPDATE name = 'jerry'
    ````

2. **Update语句,修改语句**
    * 语法 `UPDATE 需要更新的表名 SET 更新的指段名=更新的值 ，... WHERE 条件`

    ````sql
    UPDATE [IGNORE] tbl_name SET col_name1=expr1 [,col_name2=expr2,...][WHERE where_defintion]
    -- IGNORE 意义同Insert语句

    UPDATE reg SET name='张三' WHERE id = 5;
    ````

    ````sql
    -- 注意这一句非常危险，会更新所有数据
    UPDATE reg SET name = 'ben';

    -- 更新一定要加条件
    UPDATE reg SET name = 'ben',password = 'benpwd' WHERE id = 1;
    ````

3. **Delete语句，删除语句**
    * 语法 `DELETE FROM 表名 [WHERE 条件]`

    ````sql
    DELETE FROM tbl_name [WHERE where_definition]
    -- 删除复合条件的记录
    ````

    ````sql
    --删除一定要有条件，否则非常危险
    DELETE FROM reg WHERE id = 1;
    ````

4. **Select语句，查询语句**
    * 语法 `SELECT [DISTINCT] 字段名 FROM 表名 [WHERE 条件] [GROUP BY 需要分组的字段名 [HAVING 条件]] [ORDER BY 需要排序的字段名 [ASC | DESC]] [LIMIT {[offset,] row_count | row_count OFFSET offset}] [FOR UPDATE | LOCK IN SHARE MODE]`

    ````sql
    SELECT
        [DISTINCT]
        select_expr,...
        FROM table_references
        [WHERE where_definition]
        [GROUP BY {col_name | expr | position}
            [ASC | DESC],...[WITH ROLLUP]]
        [HAVING where_definition]
        [ORDER BY {col_name | expr | position}
            [ASC | DESC],...]
        [LIMIT {[offset,] row_count | row_count OFFSET offset}]
        [FOR UPDATE | LOCK IN SHARE MODE]
    ````

    * FOR UPDATE会把行进行写锁，这是排它锁。



















