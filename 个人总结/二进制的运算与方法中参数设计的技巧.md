# 二进制的运算与方法中参数设计的技巧
**前言**：假设有3个基本物体，分别代表 “a”，“b”,"c"。剩下的其他物体都是由这三种物体组合而成。例如：“ab”,"ac","bc","abc"。这种在数学上是典型的排列组合问题，一共有7种状态。    
**问题**： 假定在程序设计中，在一个函数里面，如果功能是由单一的程序状态返回组合而成。那么这种程序对于状态的设定有什么技巧？    
**发现**：在python中对于re.compile(pattern,flags=0)这个方法其中flags标记的参数值设计就使用了一些独特技巧。   
* 正则表达式中一般有如下几种常用模式可以混合使用(简单举例)：
    * 默认模式defalut 
    * 单行模式 single Line
    * 多行模式 Multi Line
1. 这三种最基本的模式可以混合使用，不同混合的情况下会出现不同的效果。
而compile中只用了flags一个参数就记录了这多种模式。
跟踪原码，查看设计变量值如下：
````python
# flags
SRE_FLAG_TEMPLATE = 1 # template mode (disable backtracking)
SRE_FLAG_IGNORECASE = 2 # case insensitive
SRE_FLAG_LOCALE = 4 # honour system locale
SRE_FLAG_MULTILINE = 8 # treat target as multiline string
SRE_FLAG_DOTALL = 16 # treat target as a single string
SRE_FLAG_UNICODE = 32 # use unicode "locale"
SRE_FLAG_VERBOSE = 64 # ignore whitespace and comments
SRE_FLAG_DEBUG = 128 # debugging
SRE_FLAG_ASCII = 256 # use ascii "locale"
````  
**问题**：为什么要用1,2,4,8,16这种间隔设计？而不是1,2,3,4,5这种连续值表示。
* **规律推导**：

|十进制数|对应的二进制数|
|:-----:|----:|
|1|1|
|2|10|
|4|100|
|8|1000|
|16|10000| 

经过上面的对比，发现如果用二进制的每一位代表一个状态，那么需要多少种状态的组合就可以使用多少位的二进制来表示这些状态的所有组合。
* **规律**
1. 假定如果二进制每一位上的数表示一种独立的状态是否存在。那么需要多少种状态的不同组合，就需要设计为二进制的多少位来表示这种状态的存在与否。
2. 每一种状态初始值的设定，必须要和其对应二进制数上的位所在位置为1所表示的值相等。   

**总结**  
经过上面的分析可以发现，对于之前 “a”,"b","c"的组合问题，可以完全由二进制对应上的位置表示。假定对应规律如下：

|功能|对应二进制值|对应十进制值
|:--:|---------:|-------:|
a|1|1
b|10|2
c|100|4  

* **技巧1**：**如果需要表示三种状态同时都有，那么对应二进制值为：111，其十进制值为：7。即从[0-7]可以表示abc三种状态的任意组合。例如：[0-7]中随机取出一个数3，即对应二进制为011那么3就表示带有a和b的状态(1+2=3)。同理：对于6相应二进制为：110 那么拥有的状态为：c和b。(应为4+2=6)**   
* **技巧2**：**为了用户使用方便，我们可以设定不同状态所对应的值，例如a=1,b=2,c=4,为用户提供。这种设计当用户调用你方法时可以使用a+b或者a|b这种形式将参数传递进来，不仅为用户调用提供了简单明了的方式，还增加了用户代码的易读性。**    

在设计程序时。如果需要用到状态的组合可以使用这种技巧，可以巧妙的简化函数调用时的参数。同时还能增加用户代码的易读性。比如上面介绍的python中的re.compile(pattern,flags=0)方法中使用的flags参数传递的值。就用到了这种设计思想。在linux中权限的值例如：775等权限也是用到了类似的思想。


